#Chapter 4 -- Log messages

##4.1 Severity levels
---
In Ros, log messages are classified into five groups called **Severity levels**, which are sometimes called just **severities** and sometimes called just **levels**. The levels are, in order of increasing importance:

1. DEBUG
2. INFO
3. WARN
4. ERROR
5. FATAL

Note that, the levels themselves don't carry any inherent meaning: Generating a FATAL message will not, in itself, end your program. Likewise, generating a DEBUG message will not debug your program for you.
##4.2 An example program
---
```
#include <ros/ros.h>

int main(int argc, char **argv) {
    ros::init(argc, argv, "count_and_log");
    ros::NodeHandle nh;
    
    ros::Rate rate(10);
    for(int i = 1; ros::ok(); ++i) {
        ROS_DEBUG_STREAM("Counted to " << i);
        if((i%3) == 0)
            ROS_INFO_STREAM(i << " is divisible by 3");
        if((i%5) == 0)
            ROS_WARE_STREAM(i << " is divisible by 5");
        if((i%10) == 0)
            ROS_ERROR_STREAM(i << " is divisible by 10");
        if((i%20) == 0)
            ROS_FATAL_STREAM(i << " is divisible by 20");
        rate.sleep();
    }
}
```
##4.3 Generating log messages
---

If you prefer a printf-style, there are also macros whose names omit the **_STREAM** suffix, for example:
```
ROS_INFO(format,...);
```
This generates INFO_level log messages.
e.m.
```
RSO_INFO("position=(%.2f, %.2f) direction=%.2f",msg.x, msg.y,msg.theta);
```
Notice that there's no need to use std::endl nor any other line terminator, because the logging system is already line-oriented.

###**_Generating one-time log message_**
```
ROS_DEBUG_STREAM_ONCE(message);
ROS_INFO_STREAM_ONCE(message);
ROS_WARN_STREAM_ONCE(message);
ROS_ERROR_STREAM_ONCE(message);
ROS_FATAL_STREAM_ONCE(message);
```
###**_Generating throttled log messages_**

```
ROS_XXX_STREAM_THROTTLE(0.1, "This appears every 0.1 seconds.");
```
Each instance of any ROS_XXX_STREAM_THROTTLE macro will generate its log message the first time it is executed. Subsequent executions will be ignored, until the specified amount of time has passed.

##**_Viewing log messages_**
---
There are actually three different destinations for log messages:

1. as output on the console
2. as a message on the rosout topic
3. as an entry in a log file


###**_Console_**
DEBUG and INFO messages are printed on standard output, whereas WARN, ERROR and FATAL messages are sent to standard error.
####**_Formatting console messages_**
You can tweak the format used to print log messages on the console by setting the ROSCONSOLE_FORMAT environment variable. The default format is equivalent to"
```
[${severity}] [${time}]: ${message}
```
###**_Messages on rosout_**

In addition to appearing on the console, every log message is also published on the topic /rosout. The message type of this topic is rosgraph_msgs/Log.
Since /rosout is just an ordinary topic, you could, of course, use
```
rostopic echo /rosout
```
to see the messages directly.However, the simplest way to see /rosout messages is to use this command:
```
rqt_console
```
###**_Log files_**
Log file generated by the rosout node. As part of its callback function for the /rosout topic, this ndoe writes a line to a file with a name like this:
```
~/.ros/log/run_id/rosout.log
```
####**_Finding the run id_**
1. You can examine the output generated by roscore. Near the end of this output, you'll see a line that looks something like this.```setting/run_id to run_id```
2. You can ask the master for the current run_id,    using a command like this:```rosparam get /run_id```

###**_Checking and purging log files_**

You can use this command to see the amount of disk space in the current user account consumed by ROS logs:
```
rosclean check
```
You can remove all of the existing logs using this command:
```
rosclean purge
```
You can also delete the log files by hand.
##4.5 Enabling and disabling log messages
---
If you executed the upon programs, you might have noticed that no DEBUG-level messages are generated. 

This is a specific example of the concept of **logger levels**, the default logger level is INFO.

There are several ways to set a node's logger level.
####**_setting the logger level from the command line_**
```
rosservice call /node-name/set_logger_level ros.package-name level

e.m.
rosservice call /count_and_log/set_logger_level ros.agitr DEBUG
```
####**_Setting the logger level from a GUI_**
```
rqt_logger_level
```
####**_Setting the logger level from C++ code_**
```
#include <log4cxx/logger.h>

log4cxx::Logger::getLogger(ROSCONSOLE_DEFAULT_NAME)->setLevel(ros::console::g_level_lookup[ros::console::levels::Debug]);
ros::console::notifyLoggerLevelsChanged();
```




---